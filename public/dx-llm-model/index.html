<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=58150&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Modeling impact of LLMs on Developer Experience. | Drafting Strategy</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="In How should you adopt Large Language Models? (LLMs), we considered how LLMs might impact a company&rsquo;s developer experience. To support that exploration, I&rsquo;ve developed a system model of the developing software at the company.
In this chapter, we&rsquo;ll work through:
Summary results from this model How the model was developed, both sketching and building the model in a spreadsheet. (As discussed in the overview of systems modeling, I generally would recommend against using spreadsheets to develop most models, but it&rsquo;s educational to attempt doing so once or twice.">
    <meta name="generator" content="Hugo 0.128.2">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    <meta name="author" content="map[name:Will Larson]">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



  
    <link rel="stylesheet" href="/static/pygments.css">
  


    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:58150/dx-llm-model/">
    

    <meta property="og:url" content="http://localhost:58150/dx-llm-model/">
  <meta property="og:site_name" content="Drafting Strategy">
  <meta property="og:title" content="Modeling impact of LLMs on Developer Experience.">
  <meta property="og:description" content="In How should you adopt Large Language Models? (LLMs), we considered how LLMs might impact a company’s developer experience. To support that exploration, I’ve developed a system model of the developing software at the company.
In this chapter, we’ll work through:
Summary results from this model How the model was developed, both sketching and building the model in a spreadsheet. (As discussed in the overview of systems modeling, I generally would recommend against using spreadsheets to develop most models, but it’s educational to attempt doing so once or twice.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="strategies">
    <meta property="article:published_time" content="2024-10-06T04:00:00-07:00">
    <meta property="article:modified_time" content="2024-10-06T04:00:00-07:00">
    <meta property="article:tag" content="Model">
    <meta property="article:tag" content="Systems-Thinking">
    <meta property="article:tag" content="Eng-Strategy-Book">
    <meta property="og:image" content="http://localhost:58150/static/author.png">

  <meta itemprop="name" content="Modeling impact of LLMs on Developer Experience.">
  <meta itemprop="description" content="In How should you adopt Large Language Models? (LLMs), we considered how LLMs might impact a company’s developer experience. To support that exploration, I’ve developed a system model of the developing software at the company.
In this chapter, we’ll work through:
Summary results from this model How the model was developed, both sketching and building the model in a spreadsheet. (As discussed in the overview of systems modeling, I generally would recommend against using spreadsheets to develop most models, but it’s educational to attempt doing so once or twice.">
  <meta itemprop="datePublished" content="2024-10-06T04:00:00-07:00">
  <meta itemprop="dateModified" content="2024-10-06T04:00:00-07:00">
  <meta itemprop="wordCount" content="3008">
  <meta itemprop="image" content="http://localhost:58150/static/author.png">
  <meta itemprop="keywords" content="Model,Systems-Thinking,Eng-Strategy-Book">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:58150/static/author.png">
  <meta name="twitter:title" content="Modeling impact of LLMs on Developer Experience.">
  <meta name="twitter:description" content="In How should you adopt Large Language Models? (LLMs), we considered how LLMs might impact a company’s developer experience. To support that exploration, I’ve developed a system model of the developing software at the company.
In this chapter, we’ll work through:
Summary results from this model How the model was developed, both sketching and building the model in a spreadsheet. (As discussed in the overview of systems modeling, I generally would recommend against using spreadsheets to develop most models, but it’s educational to attempt doing so once or twice.">

	

  </head><body class="ma0 avenir bg-white development">

    
   
  <header>
  <div class="bg-white">
    <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 no-underline black-90 dib">
      
        Drafting Strategy
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="no-underline black-90" href="/about" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="no-underline black-90" href="" title=" page">
              
            </a>
          </li>
          
        </ul>
      
      















    </div>
  </div>
  
    
</nav>

  </div>
</header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      
      
      <h1 class="f1 athelas mt3 mb3">Modeling impact of LLMs on Developer Experience.</h1>
      
      

      
      

    </header>
    <div class="nested-copy-line-height lh-copy serif f5 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>In <a href="/llm-adoption-strategy/">How should you adopt Large Language Models?</a> (LLMs), we considered how
LLMs might impact a company&rsquo;s developer experience. To support that exploration, I&rsquo;ve developed a <a href="/strategy-systems-modeling/">system model</a> of
the developing software at the company.</p>
<p>In this chapter, we&rsquo;ll work through:</p>
<ol>
<li>Summary results from this model</li>
<li>How the model was developed, both sketching and building the model in a spreadsheet.
(As discussed in <a href="/strategy-systems-modeling/">the overview of systems modeling</a>,
I generally would recommend against using spreadsheets to develop most models,
but it&rsquo;s educational to attempt doing so once or twice.)</li>
<li>Exercise the model to see what it has to teach us</li>
</ol>
<p>Let&rsquo;s get into it.</p>
<hr>
<p><em>This is an exploratory, draft chapter for a book on engineering strategy that I’m brainstorming in</em>
<em><a href="/tags/eng-strategy-book/">#eng-strategy-book</a>.</em>
<em>As such, some of the links go to other draft chapters, both published drafts and very early, unpublished drafts.</em></p>
<h2 id="learnings">Learnings</h2>
<p>This model&rsquo;s insights can be summarized in three charts.
First, the baseline chart, which shows an eventual equilibrium between errors discovered
in production and tickets that we&rsquo;ve closed by shipping to production.
This equilibrium is visible because tickets continue to get opened, but the total number of
closed tickets stop increasing.</p>
<p><img src="/static/blog/strategy/dx-chart-1.png" alt="Chart showing systems modeling"></p>
<p>Second, we show that we can shift that equilibrium by reducing the error rate in production.
Specifically, the first chart models 25% of closed tickets in production experiencing an error,
whereas the second chart models only a 10% error rate.
The equilibrium returns, but at a higher value of shipped tickets.</p>
<p><img src="/static/blog/strategy/dx-chart-2.png" alt="Chart showing systems modeling"></p>
<p>Finally, we can see that even tripling the rate that we start and test tickets
doesn&rsquo;t meaningfully change the total number of completed tickets,
as modeled in this third chart.</p>
<p><img src="/static/blog/strategy/dx-chart-4.png" alt="Chart showing systems modeling"></p>
<p>The constraint on this system is errors discovered in production,
and any technique that changes something else doesn&rsquo;t make much of an impact.
Of course, this is just <em>a model</em>, not reality. There are many nuances
that models miss, but this helps us focus on what probably matters the most,
and in particular highlights that any approach that increases development velocity
while also increasing production error rate is likely net-negative.</p>
<p>With that summary out of the way, now we can get into developing the model itself.</p>
<h2 id="sketch">Sketch</h2>
<p>Modeling in a spreadsheet is labor intensive, so we want to iterate as much as possible
in the sketching phase, before we move to the spreadsheet.
In this case, we&rsquo;re working with <a href="https://excalidraw.com/">Excalidraw</a>.</p>
<p><img src="/static/blog/strategy/llm-dx-model-1.png" alt="Systems model with five stages of development, with numerous lines where discovered errors require moving backwards in flow."></p>
<p>I sketched five stocks to represent a developer&rsquo;s workflow:</p>
<ol>
<li><code>Open Tickets</code> is tickets opened for an engineer to work on</li>
<li><code>Start Coding</code> is tickets that an engineer is working on</li>
<li><code>Tested Code</code> is tickets that have been tested</li>
<li><code>Deployed Code</code> is tickets than have been deployed</li>
<li><code>Closed Ticket</code> is tickets that are closed after reaching production</li>
</ol>
<p>There are four flows representing tickets progressing through this development process from left to right.
Additionally, there are three exception flows that move from right to left:</p>
<ol>
<li><code>Testing found error</code> represents a ticket where testing finds an error, moving the ticket backwards to <code>Start Coding</code></li>
<li><code>Deployment exposed error</code> represents a ticket encountering an error during deployment, where it&rsquo;s moved backwards to <code>Start Coding</code></li>
<li><code>Error found in production</code> represents a ticket encountering a production error, which causes it to move all the way back to the beginning as a new ticket</li>
</ol>
<p>One of your first concerns seeing this model might be that it&rsquo;s embarassingly simple.
To be honest, that was my reaction when I first looked at it, too.
However, it&rsquo;s important to recognize that feeling and then dig into whether it matters.</p>
<p>This model is quite simple, but in the next section we&rsquo;ll find that it reveals several
counter-intuitive insights into the problem that will help us avoid erroneously viewing the
tooling as a failure if time spend testing increases.
The value of a model is in refining our thinking, and simple models are usually more effective
as refining thinking across a group than complex models, simply because complex models are fairly
difficult to align a group around.</p>
<h2 id="reason">Reason</h2>
<p>As we start to look at this sketch, the first question to ask is how might LLM-based tooling show an improvement?
The most obvious options are:</p>
<ol>
<li>
<p>Increasing the rate that tasks flow from <code>Starting coding</code> to <code>Tested code</code>.
Presumably these tools might reduce the amount of time spent on implementation.</p>
</li>
<li>
<p>Increasing the rate that <code>Tested code</code> follows <code>Testing found errors</code> to return to <code>Starting code</code>
because more comprehensive tests are more likely to detect errors.
This is probably the first interesting learning from this model: if the adopted tool works well, it&rsquo;s likely that we&rsquo;ll spend
<em>more</em> time in the testing loop, with a long-term payoff of spending less time solving problems in production where it&rsquo;s more expensive.
This means that slower testing might be a successful outcome rather than a failure as it might first appear.</p>
<p>A skeptic of these tools might argue the opposite, that LLM-based tooling will cause more issues to be identified &ldquo;late&rdquo;
after deployment rather than early in the testing phase. In either case, we now have a clear goal to measure to evaluate
the effectiveness of the tool: reducing the <code>Error found in production</code> flow. We also know <em>not</em> to focus on the
<code>Testing found error</code> flow, which should probably increase.</p>
</li>
<li>
<p>Finally, we can also zoom out and measure the overall time from <code>Start Coding</code> to <code>Closed Ticket</code> for tasks
that don&rsquo;t experience the <code>Error found in production</code> flow for at least the first 90 days after being completed.</p>
</li>
</ol>
<p>These observations capture what I find remarkable about systems modeling: even a very simple model
can expose counter-intuitive insights. In particular, the sort of insights that build conviction to push
back on places where intuition might lead you astray.</p>
<h2 id="model">Model</h2>
<p>For this model, we&rsquo;ll be modeling it directly in a spreadsheet, specifically Google Sheets.
The completed spreadsheet model <a href="https://docs.google.com/spreadsheets/d/1YAego3JiNCUE15GeL_3GQfYmrE1jG9dVF6yzu-mAxLw/edit?gid=1325089804#gid=1325089804">is available here</a>.
As discussed in <a href="/strategy-systems-modeling/">Systems modeling to refine strategy</a>, spreadsheet modeling
is brittle, slow and hard to iterate on. I generally recommend that folks attempt to model something in a spreadsheet
to get an intuitive sense of the math happening in their models, but I would almost always choose any tool other
than a spreadsheet for a complex model.</p>
<p>This example is fairly tedious to follow, and you&rsquo;re entirely excused if you decide to pull open the sheet itself,
look around a bit, and then skip the remainder of this section.
If you are hanging around, it&rsquo;s time to get started.</p>
<p>The spreadsheet we&rsquo;re creating has three important worksheets:</p>
<ul>
<li><em>Model</em> represents the model itself</li>
<li><em>Charts</em> holds charts of the model</li>
<li><em>Config</em> holds configuration values seperately from the model to ease exercising the model after we&rsquo;ve built it</li>
</ul>
<p>Going to the model worksheet, we want to start out by initializing each of the columns to the starting value.</p>
<p><img src="/static/blog/strategy/dx-model-screeshot-0.png" alt="Screenshot of spreadsheet showing initial values of a systems model"></p>
<p>While we&rsquo;ll use formulae for subsequent rows, the first row should contain literal values. I often start with
a positive value in the first column and zeros in the other columns, but that isn&rsquo;t required.
You can start with whatever starting values are more useful for studying the model that you&rsquo;re building.</p>
<p>With the initial values set, we&rsquo;re now going to implement the model in two passes.
First, we&rsquo;ll model the left-to-right flows, which represent the standard development process.
Second, we&rsquo;ll model the right-to-left flows, which represent exceptions in the process.</p>
<h3 id="modeling-left-to-right">Modeling left-to-right</h3>
<p>We&rsquo;ll start by modeling the interaction between the first two nodes: <code>Open Tickets</code> and <code>Started Coding</code>.
We want to have open tickets increased over time at a fixed rate, so let&rsquo;s add a value in the config worksheet
for <code>TicketOpenRate</code>, starting with <code>1</code>.</p>
<p>Moving to the second stock, we want to start work on open tickets as long as we have at most <code>MaxConcurrentCodingNum</code> open tickets.
If we have more than <code>MaxConcurrentCodingNum</code> tickets that we&rsquo;re working on, then we don&rsquo;t start working on any new tickets.
To do this, we actually need to create an intermediate value (represented using an italics column name) to determine how
many should be created by checking if the current in started tickets is at maximum (another value in the config sheet)
or if we should increment that by one.</p>
<p>That looks like:</p>
<pre><code>// Config!$B$3 is max started tickets
// Config!$B$2 is rate to increment started tickets
// $ before a row or column, e.g. $B$3 means that the row or column
//   always stays the same -- not incrementing -- even when filled
//   to other cells
= IF(C2 &gt;= Config!$B$3, 0, Config!$B$2)
</code></pre>
<p>This also means that our first column, for <code>Open Tickets</code> is decremented by the number of tickets that
we&rsquo;re started coding:</p>
<pre><code>// This is the definition of `Open Tickets`
=A2 + Config!$B$1 - B2
</code></pre>
<p>Leaving us with these values.</p>
<p><img src="/static/blog/strategy/dx-model-screeshot-1.png" alt="Screenshot of spreadsheet showing three columns of systems modeling"></p>
<p>Now we want to determine the number of tickets being tested at each step in the model.
To do this, we create a calculation column, <code>NumToTest?</code> which is defined as:</p>
<pre><code>// Config$B$4 is the rate we can start testing tickets
// Note that we can only start testing tickets if there are tickets
// in `Started Coding` that we're able to start testing
=MIN(Config!$B$4, C3)
</code></pre>
<p>We then add that value to the previous number of tickets being tested.</p>
<pre><code>// E2 is prior size of the Tested Code stock
// D3 is the value of `NumToTest?`
// F2 is the number of tested tickets to deploy
=E2 + D3 - F2
</code></pre>
<p><img src="/static/blog/strategy/dx-model-screeshot-2.png" alt="Screenshot of spreadsheet showing three columns of systems modeling"></p>
<p>Moving on to deploying code, let&rsquo;s keep things simple and start out by assuming that every tested change
is going to get deployed. That means the calculation for <code>NumToDeploy?</code> is quite simple:</p>
<pre><code>// E3 is the number of tested changes
=E3
</code></pre>
<p>Then the value for the <code>Deployed Code</code> stock is simple as well:</p>
<pre><code>// G2 is the prior size of Deployed Code
// F3 is NumToDeploy?
// H2 is the number of deployed changes in prior round
=G2+F3-H2
</code></pre>
<p><img src="/static/blog/strategy/dx-model-screeshot-3.png" alt="Screenshot of spreadsheet showing three columns of systems modeling"></p>
<p>Now we&rsquo;re on to the final stock.
We add the <code>NumToClose?</code> calculation, which assumes that all deployed changes are now closed.</p>
<pre><code>// G3 is the number of deployed changes
=G3
</code></pre>
<p>This makes the calculation for the <code>Closed Tickets</code> stock:</p>
<pre><code>// I2 is the prior value of Closed Tickets
// H3 is the NumToClose?
=I2 + H3
</code></pre>
<p>With that, we&rsquo;ve now modeled the entire left-to-right flows.</p>
<p><img src="/static/blog/strategy/dx-model-screeshot-4.png" alt="Screenshot of spreadsheet showing three columns of systems modeling"></p>
<p>The left-to-right flows are simple, with a few constrained flows and a very scalable flows, but overall we see things
progressing through the pipeline evenly.
All that is about to change!</p>
<h3 id="modeling-right-to-left">Modeling right-to-left</h3>
<p>We&rsquo;ve now finished modeling the happy path from left to right.
Next we need to model all the exception paths where things flow right to left.
For example, an issue found in production would cause a flow from <code>Closed Ticket</code>
back to <code>Open Ticket</code>.
This tends to be where models get interesting.</p>
<p>There are three right-to-left flows that we need to model:</p>
<ol>
<li><code>Closed Ticket</code> to <code>Open Ticket</code> represents a bug discovered in production.</li>
<li><code>Deployed Code</code> to <code>Start Coding</code> represents a bug discovered during deployment.
3 <code>Tested Code</code> to <code>Start Coding</code> represents a bug discovered in testing.</li>
</ol>
<p>To start, we&rsquo;re going to add configurations defining the rates of those flows.
These are going to be percentage flows, with a certain percentage of the target stock
triggering the error condition rather than proceeding. For example, perhaps 25% of the
<code>Closed Tickets</code> are discovered to have a bug each round.</p>
<p><img src="/static/blog/strategy/dx-model-screeshot-5.png" alt="Screenshot of spreadsheet showing three columns of systems modeling"></p>
<p>These are fine starter values, and we&rsquo;ll experiment with how adjusting them changes the model in the <em>Exercise</em> section below.</p>
<p>Now we&rsquo;ll start by modeling errors discovered in production, by adding a column
to model the flow from <code>Closed Tickets</code> to <code>Open Tickets</code>, the <code>ErrorsFoundInProd?</code> column.</p>
<pre><code>// I3 is the number of Closed Tickets
// Config!$B$5 is the rate of errors
=FLOOR(I3 * Config!$B$5)
</code></pre>
<p>Note the usage of <code>FLOOR</code> to avoid moving partial tickets.
Feel free to skip that entirely if you&rsquo;re comfortable with the concept of fractional tickets, fractional deploys, and so on.
This is an aesthetic consideration, and generally only impacts your model if you choose overly small starting values.</p>
<p>This means that our calculation for <code>Closed Ticket</code> needs to be
updated as well to reduce by the prior row&rsquo;s result for <code>ErrorsFoundInProd?</code>:</p>
<pre><code>// I2 is the prior value of ClosedTicket
// H3 is the current value of NumToClose?
// J2 is the prior value of ErrorsFoundInProd?
=I2 + H3 - J2
</code></pre>
<p>We&rsquo;re not quite done, because we <em>also</em> need to add the prior row&rsquo;s value of <code>ErrorsInProd?</code>
into <code>Open Tickets</code>, which represents the errors&rsquo; flow from closed to open tickets.
Based on this change, the calculation for <code>Open Tickets</code> becomes:</p>
<pre><code>// A2 is the prior value of Open Tickets
// Config!$B$1 is the base rate of ticket opening
// B2 is prior row's StartCodingMore?
// J2 is prior row's ErrorsFoundInProd?
=A2 + Config!$B$1 - B2 + J2
</code></pre>
<p>Now we have the full errors in production flow represented in our model.</p>
<p><img src="/static/blog/strategy/dx-model-screeshot-6.png" alt="Screenshot of spreadsheet showing three columns of systems modeling"></p>
<p>Next, it&rsquo;s time to add the <code>Deployed Code</code> to <code>Start Coding</code> flow.
Start by adding the <code>ErrorsFoundInProd?</code> calculation:</p>
<pre><code>// G3 is deployed code
// Config!$B$6 is deployed error rate
=FLOOR(G3 * Config!$B$6)
</code></pre>
<p>Then we need to update the calculation for <code>Deployed Code</code> to decrease by the
calculated value in <code>ErrorsFoundInProd?</code>:</p>
<pre><code>// G2 is the prior value of Deployed Code
// F3 is NumToDeploy?
// H2 is prior row's NumToClose?
// I2 is ErrorsFoundInDeploy?
=G2 + F3 - H2 - I2
</code></pre>
<p>Finally, we need to increase the size of <code>Started Coding</code> by the same value,
representing the flow of errors discovered in deployment:</p>
<pre><code>// C2 is the prior value of Started Coding
// B3 is StartCodingMore?
// D2 is prior value of NumToTest?
// I2 is prior value of ErrorsFoundInDeploy?
=C2 + B3 - D2 + I2
</code></pre>
<p>We now have the working flow representing errors in production.</p>
<p><img src="/static/blog/strategy/dx-model-screeshot-7.png" alt="Screenshot of spreadsheet showing three columns of systems modeling"></p>
<p>Finally, we can added the <code>Tested Code</code> to <code>Started Coding</code> flow.
This is pretty much the same as the prior flow we added,
starting with adding a <code>ErrorsFoundInTest?</code> calculation:</p>
<pre><code>// E3 is tested code
// Config!$B$7 is the testing error rate
=FLOOR(E3 * Config!$B$7)
</code></pre>
<p>Then we update <code>Tested Code</code> to reduce by this value:</p>
<pre><code>// E2 is prior value of Tested Code
// D3 is NumToTest?
// G2 is prior value of NumToDeploy?
// F2 is prior value of ErrorsFoundInTest?
=E2 + D3 - G2 - F2
</code></pre>
<p>And update <code>Started Coding</code> to increase by this value:</p>
<pre><code>// C2 is prior value of Started Coding
// B3 is StartCodingMore?
// D2 is prior value of NumToTest?
// J2 is prior value of ErrorsFoundInDeploy?
// F2 is prior value of ErrorsFoundInTest?
= C2 + B3 - D2 + J2 + F2
</code></pre>
<p>Now this last flow is instrumented.</p>
<p><img src="/static/blog/strategy/dx-model-screeshot-8.png" alt="Screenshot of spreadsheet showing three columns of systems modeling"></p>
<p>With that, we now have a complete model that we can start exercising!
This exercise demonstrated both that it&rsquo;s <em>quite possible</em> to represent
a meaningful model in a spreadsheet, but also the challenges of doing so.</p>
<p>While developing this model, a number of errors became evident. Some of them
I was able to fix relatively easily, and even more I left unfixed because fixing
them makes the model <em>even harder</em> to reason about. This is a good example of why
I encourage developing one or two models in a spreadsheet, but I ultimately don&rsquo;t
believe it&rsquo;s the right mechanism to work in for most people:
even very smart people make errors in their spreadsheets, and catching those errors
is exceptionally challenging.</p>
<h2 id="exercise">Exercise</h2>
<p>Now that we&rsquo;re done building this model, we can final start the fun part: exercising it.
We&rsquo;ll start by creating a simple bar chart showing the size of each stock at each step.
We are going to expressly <em>not</em> show the intermediate calculation columns such as <code>NumToTest?</code>,
because those are implementation details rather than particularly interesting.</p>
<p>Before we start tweaking the values , let&rsquo;s look at the baseline chart.</p>
<p><img src="/static/blog/strategy/dx-chart-1.png" alt="Chart showing systems modeling"></p>
<p>The most interesting thing to notice is that our current model doesn&rsquo;t actually increase the number of closed
tickets over time. We actually just get further and further behind over time, which isn&rsquo;t too exciting.</p>
<p>So let&rsquo;s start modeling the first way that LLMs might help, reducing the error rate in production.
Let&rsquo;s shift <code>ErrorsInProd</code> from <code>0.25</code> down to <code>0.1</code>, and see how that impacts the chart.</p>
<p><img src="/static/blog/strategy/dx-chart-2.png" alt="Chart showing systems modeling"></p>
<p>We can see that this allows us to make more progress on closing tickets, although
at some point equilibrium is established between closed tickets and the error rate in production,
preventing further progress. This does validate that reducing error rate in production matters.
It also suggests that as long as error rate is a function of everything we&rsquo;ve previously shipped,
we are eventually in trouble.</p>
<p>Next let&rsquo;s experiment with the idea that LLMs allow us to test more quickly,
tripling <code>TicketTestRate</code> from <code>1</code> to <code>3</code>. It turns out, increasing testing rate doesn&rsquo;t change anything at all,
because the current constraint is in starting tickets.</p>
<p><img src="/static/blog/strategy/dx-chart-3.png" alt="Chart showing systems modeling"></p>
<p>So, let&rsquo;s test that. Maybe LLMs make us faster in starting tickets because <em>overall</em> speed of development goes down.
Let&rsquo;s model that by increasing <code>StartCodingRate</code> from <code>1</code> to <code>3</code> as well.</p>
<p><img src="/static/blog/strategy/dx-chart-4.png" alt="Chart showing systems modeling"></p>
<p>This is a fascinating result, because tripling development and testing velocity has changed how much work we start,
but ultimately the real constraint in our system is the error discovery rate in production.</p>
<p>By exercising this model, we find an interesting result. To the extent that our error rate is a function of the volume
of things we&rsquo;ve shipped in production, shipping faster doesn&rsquo;t increase our velocity at all.
The only meaningful way to increase productivity in this model is to reduce the error rate in production.</p>
<p>Models are imperfect representations of reality, but this one gives us a clear sense of what matters the most:
if we want to increase our velocity, we have to reduce the rate that we discover errors in production.
That might be reducing the error rate as implied in this model, or it might be ideas that exist outside of this model.
For example, the model doesn&rsquo;t represent this well, but perhaps we&rsquo;d be better off iterating more on fewer things to avoid this scenario.
If we make multiple changes to one area, it still just represents one implemented feature, not many implement features, and the overall error
rate wouldn&rsquo;t increase.</p>
<div class="mt4">
        <hr>
        
        <p class="f5"><span class="b mb3">Next chapter: </span> <a href="/wardley-llm-ecosystem/">Wardley mapping the LLM ecosystem.</a></p>
        
        
        <p class="f5"><span class="b mb3">Previous chapter: </span> <a href="/llm-adoption-strategy/">How should you adopt LLMs?</a></p>
                
      </div>
      
      <div class="bg-light-gray br4 ph3 pv1">
        <p class="tracked">First published at <a href="https://lethain.com/dx-llm-model/">lethain.com/dx-llm-model/</a></p>      
      </div>
      

      <div class="mt6 instapaper_ignoref">
      
      </div>
    </div>

    <aside class="w-30-l mt1-l"><div class="bg-light-gray pa3 cf">
  <p class="f5 mb3">
    Hi folks. I'm <a href="https://lethain.com/about">Will Larson</a>,
    and this is my new book on engineering strategy, <em><a href="https://draftingstrategy.com/">Drafting Strategy</a></em>.
  </p>

  <p>
    I also wrote

    <em><a href="https://www.amazon.com/Elegant-Puzzle-Systems-Engineering-Management/dp/1732265186">An Elegant Puzzle</a></em>,
    <em><a href="https://staffeng.com/book">Staff Engineer</a></em>, and
      <em><a href="https://www.oreilly.com/library/view/the-engineering-executives/9781098149475/">The Engineering Executive's Primer</a></em>.
  </p>

  <p class="cf">
    <div class="fl w-third">
      <a href="https://www.amazon.com/Elegant-Puzzle-Systems-Engineering-Management/dp/1732265186">
        <img src="/static/aep-small-lq.jpg">
      </a>
    </div>
    <div class="fl w-third">    
      <a href="https://staffeng.com/book">
        <img src="/static/StaffEngBookMed.jpg">
      </a>
    </div>
    <div class="fl w-third">
      <a href="https://www.oreilly.com/library/view/the-engineering-executives/9781098149475/">
        <img src="/static/primer-cover-small.jpg">
      </a>
    </div>    
  </p>
</div>

<div class="bg-light-gray ph3 cf">
  <p class="f5 mb3">
    For updates on this project, join <em>Irrational Exuberance</em>'s
    <a href="/newsletter/">weekly newsletter</a>.
  </p>
</div>


<div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
  
    <p class="f5"><span class="b mb3">Next chapter</span></p>
    <p class="f5"><a href="/wardley-llm-ecosystem/">Wardley mapping the LLM ecosystem.</a></p>
    
    
  
    <p class="f5"><span class="b mb3">Previous chapter</span></p>
    <p class="f5"><a href="/llm-adoption-strategy/">How should you adopt LLMs?</a></p>
  
  <p class="f5 b mb3">Table of Contents</p>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#learnings">Learnings</a></li>
    <li><a href="#sketch">Sketch</a></li>
    <li><a href="#reason">Reason</a></li>
    <li><a href="#model">Model</a>
      <ul>
        <li><a href="#modeling-left-to-right">Modeling left-to-right</a></li>
        <li><a href="#modeling-right-to-left">Modeling right-to-left</a></li>
      </ul>
    </li>
    <li><a href="#exercise">Exercise</a></li>
  </ul>
</nav>
</div>
</aside>

  </article>

    </main>
    <footer class="bg-white bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="center f4 fw4 hover-white no-underline black-50 dn dib-ns pv2 ph3" href="http://localhost:58150/" >
    &copy;  Will Larson 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
